# Continuity ledger (per-branch)

## Human intent (must not be overwritten)

- Implement the missing public API needed for `@giselles-ai/sdk` `runAndWait`, so server-side integrations can run an App and wait for completion via polling.

## Goal (incl. success criteria)

- Add a public status/results endpoint that the SDK can poll after `POST /api/apps/{appId}/run`.
- Implement SDK `runAndWait()` to poll until the task reaches a terminal status, then return final data.

## Constraints/Assumptions

- Keep the public API minimal and scoped to a single App (avoid cross-app task access).
- Do not try to match Studio UI task page data shape; only reuse the polling mechanism.

## Key decisions

- Implement `GET /api/apps/{appId}/tasks/{taskId}` with optional `?includeGenerations=1` for the final fetch.
- SDK polls status-only until terminal, then does one final `includeGenerations=1` fetch.

## State

- `POST /api/apps/{appId}/run` already exists and returns `{ taskId }`.
- Task JSON is stored in Giselle Storage and can be loaded via `giselle.getTask({ taskId })`.

## Done

- Added Studio API route: `GET /api/apps/{appId}/tasks/{taskId}` (API key auth + ownership check + optional generations).
- Implemented `@giselles-ai/sdk` `runAndWait()` to poll the new endpoint and return `{ task, generationsById }`.
- Updated SDK tests and README accordingly.

## Now

- Sandbox does not have `node_modules`, so `pnpm -F @giselles-ai/sdk test` and `pnpm -F @giselles-ai/sdk format` fail with missing `vitest`/`biome`.

## Next

- Run `pnpm install` (outside sandbox) and then:
  - `pnpm -F @giselles-ai/sdk test`
  - `pnpm -F @giselles-ai/sdk format`

## Open questions (UNCONFIRMED if needed)

- None.

## Working set (files/ids/commands)

- `apps/studio.giselles.ai/app/api/apps/[appId]/tasks/[taskId]/route.ts`
- `packages/sdk/src/sdk.ts`
- `packages/sdk/src/sdk.test.ts`
- `packages/sdk/src/errors.ts`
- `packages/sdk/README.md`
- `pnpm -F @giselles-ai/sdk test`
- `pnpm -F @giselles-ai/sdk format`

